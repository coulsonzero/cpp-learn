# C++
```shell
$ cloc ./

540 text files.
216 unique files.                                          
429 files ignored.

github.com/AlDanial/cloc v 1.92  T=0.12 s (1756.8 files/s, 55681.1 lines/s)
-------------------------------------------------------------------------------
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
C++                             87            722            498           2163
CMake                          108            260            320           1287
C                                1            120             50            521
XML                              7              0              0            271
C/C++ Header                     8             68             56            263
make                             2             62             49             92
Python                           2             10              4             25
Bourne Shell                     1              1              0              4
-------------------------------------------------------------------------------
SUM:                           216           1243            977           4626
-------------------------------------------------------------------------------
```


**C++ 与 Rust 内存安全性问题 分析**
```
    C++ 之父的论证和这个问题下的其他一些答主的论证一样，都是在强调“你看，我用 C++ 确实能写出非常内存安全的代码，而且现代 C++ 正在变得越来越安全”。
我完全赞同 C++ 能写出内存安全性媲美 Rust 的代码，我也完全赞同 Rust 并不能达到 100% 的内存安全。
核心问题和差距在于，C++ 在语核的层面并没有某一类强制性约束来提升代码内存安全性，而 Rust 对于内存安全的保证是在语核层面完成的。
    换句话说，写能通过编译能运行的 C++ 代码本身是没有安全保障的，你必须通过广泛地使用安全的编程范式、广泛地使用符合安全编程范式的库、
广泛地使用各种静态分析工具、广泛地应用先进的软件工程管理手段等各种非强制性手段，才能保障产出代码的内存安全性；
而写 Rust 代码时这些都是完全默认的，只有在写不安全的代码时才必须显式地使用 unsafe 机制进行绕过。
也就是说，在 C++ 里面，内存不安全是免费的，你需要花额外的精力和成本（而且这部分精力和成本可能还不少）才能保证内存安全性；
而 Rust 恰好相反，内存安全是免费的，你需要花额外的精力和成本才能实现任何编译器认为不安全的行为。
当然这并不是说 C++ 就比 Rust 差，只能说这两门语言的设计目标并不一致，内存安全性并非 C++ 的首要目标。
Rust 牺牲了灵活性才得到了内存安全性。

    稍微有信息安全常识的读者应该知道，一个系统的安全性并非取决于安全性保障最强的环节，
而是取决于安全性保障最弱的环节（也就是木桶原理）。衡量一个系统的安全性，不但要衡量系统本身的安全性，也要衡量作为系统用户的人的安全性。
而人都是有惰性的，绝大部分开发者能少写代码就少写，能用简单方法就绝不会用复杂方法，代码能编译能跑就行。
那么你认为大众开发者会严格遵循上述的各种保障内存安全性的非强制性措施吗？显然不会。
因此，只要 C++ 没有在语核中添加对内存安全性的强制性约束，没有做到“安全是免费的，不安全才是付费的”，那么 C++ 的内存安全性永远达不到 Rust 的高度。

作者：Lancern
链接：https://www.zhihu.com/question/584122632/answer/2894670751
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```